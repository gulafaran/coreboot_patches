From e7277a57819a8ee53c1c1da0ffc4734e3191a89a Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 1 Jan 2021 08:14:59 +0100
Subject: [PATCH] add intel me/tcpded/tprpden to cmos

---
 src/mainboard/lenovo/x230/cmos.default        |   3 +
 src/mainboard/lenovo/x230/cmos.layout         |   9 +-
 .../intel/sandybridge/raminit_common.c        |  31 +++-
 src/southbridge/intel/bd82x6x/Makefile.inc    |   1 +
 src/southbridge/intel/bd82x6x/early_me.c      |  24 +--
 src/southbridge/intel/bd82x6x/early_me_mrc.c  |  22 +--
 src/southbridge/intel/bd82x6x/me.c            | 134 ++++++++++++++++-
 src/southbridge/intel/bd82x6x/me.h            |  18 +++
 src/southbridge/intel/bd82x6x/me_8.x.c        | 137 +++++++++++++++++-
 src/southbridge/intel/bd82x6x/me_common.c     |  25 ++++
 src/southbridge/intel/ibexpeak/Makefile.inc   |   1 +
 11 files changed, 359 insertions(+), 46 deletions(-)

diff --git a/src/mainboard/lenovo/x230/cmos.default b/src/mainboard/lenovo/x230/cmos.default
index 17d20e69d2..cb9f46b617 100644
--- a/src/mainboard/lenovo/x230/cmos.default
+++ b/src/mainboard/lenovo/x230/cmos.default
@@ -26,3 +26,6 @@ onboard_vga_primary=Disable
 trwdrdd=Auto
 trwsr=Auto
 dll_off=Disable
+tcpded=Auto
+tprpden=Auto
+me_state=Normal
diff --git a/src/mainboard/lenovo/x230/cmos.layout b/src/mainboard/lenovo/x230/cmos.layout
index dabbe05e17..e24fa32392 100644
--- a/src/mainboard/lenovo/x230/cmos.layout
+++ b/src/mainboard/lenovo/x230/cmos.layout
@@ -49,6 +49,11 @@ entries
 449	3	e	15	trwdrdd
 452	3	e	15	trwsr
 455	1	e	1	dll_off
+456	3	e	15	tcpded
+460	3	e	15	tprpden
+464	1	e	16	me_state
+465	2	h	0	me_state_prev
+#467	4	5	9	unused
 
 440	8	h	0	volume
 
@@ -118,8 +123,10 @@ enumerations
 15	4	4
 15	5	5
 15	6	6
+16	0	Normal
+16	1	Disabled
 
 # -----------------------------------------------------------------
 checksums
 
-checksum 392 455 984
+checksum 392 559 984
diff --git a/src/northbridge/intel/sandybridge/raminit_common.c b/src/northbridge/intel/sandybridge/raminit_common.c
index f9a9a4a2fa..af2b8cd044 100644
--- a/src/northbridge/intel/sandybridge/raminit_common.c
+++ b/src/northbridge/intel/sandybridge/raminit_common.c
@@ -149,6 +149,20 @@ static void dram_odt_stretch(ramctr_timing *ctrl, int channel)
 void dram_timing_regs(ramctr_timing *ctrl)
 {
 	int channel;
+	u8 cmos_tcpded = 0;
+	u8 cmos_tprpden = 0;
+
+	if(get_option(&cmos_tcpded, "tcpded") == CB_SUCCESS) {
+		if(cmos_tcpded == 0) {
+			printk(RAM_DEBUG, "tcpded set to Auto, using defaults.\n");
+		}
+	}
+
+	if(get_option(&cmos_tprpden, "tprpden") == CB_SUCCESS) {
+		if(cmos_tprpden == 0) {
+			printk(RAM_DEBUG, "tprpden set to Auto, using defaults.\n");
+		}
+	}
 
 	/* BIN parameters */
 	const union tc_dbp_reg tc_dbp = {
@@ -170,13 +184,26 @@ void dram_timing_regs(ramctr_timing *ctrl)
 		.tCMD = 3,
 	};
 
+	u32 tcpded_default = 2;
+	u32 tprpden_default = 1;
+
+	if(cmos_tcpded > 0) {
+		tcpded_default = cmos_tcpded;
+	}
+	if(cmos_tprpden > 0) {
+		tprpden_default = cmos_tprpden;
+	}
+
+	printk(RAM_DEBUG, "tcpded set to %x .\n", tcpded_default);
+	printk(RAM_DEBUG, "tprpden set to %x .\n", tprpden_default);
+
 	/* Other parameters */
 	const union tc_othp_reg tc_othp = {
 		.tXPDLL  = ctrl->tXPDLL,
 		.tXP     = ctrl->tXP,
 		.tAONPD  = ctrl->tAONPD,
-		.tCPDED  = 2,
-		.tPRPDEN = 1,
+		.tCPDED  = tcpded_default,
+		.tPRPDEN = tprpden_default,
 	};
 
 	/*
diff --git a/src/southbridge/intel/bd82x6x/Makefile.inc b/src/southbridge/intel/bd82x6x/Makefile.inc
index 687fc97d4c..8d82b01dc2 100644
--- a/src/southbridge/intel/bd82x6x/Makefile.inc
+++ b/src/southbridge/intel/bd82x6x/Makefile.inc
@@ -31,6 +31,7 @@ smm-y += smihandler.c me.c me_8.x.c pch.c me_common.c
 romstage-y += me_status.c
 romstage-y += early_rcba.c
 romstage-y += early_pch.c
+romstage-y += me_common.c
 
 ifeq ($(CONFIG_USE_NATIVE_RAMINIT),y)
 romstage-y += early_thermal.c early_me.c early_usb.c
diff --git a/src/southbridge/intel/bd82x6x/early_me.c b/src/southbridge/intel/bd82x6x/early_me.c
index 6320d2ea9f..b7a3b44d06 100644
--- a/src/southbridge/intel/bd82x6x/early_me.c
+++ b/src/southbridge/intel/bd82x6x/early_me.c
@@ -91,22 +91,6 @@ int intel_early_me_uma_size(void)
 	return 0;
 }
 
-static inline void set_global_reset(int enable)
-{
-	u32 etr3 = pci_read_config32(PCH_LPC_DEV, ETR3);
-
-	/* Clear CF9 Without Resume Well Reset Enable */
-	etr3 &= ~ETR3_CWORWRE;
-
-	/* CF9GR indicates a Global Reset */
-	if (enable)
-		etr3 |= ETR3_CF9GR;
-	else
-		etr3 &= ~ETR3_CF9GR;
-
-	pci_write_config32(PCH_LPC_DEV, ETR3, etr3);
-}
-
 int intel_early_me_init_done(u8 status)
 {
 	u8 reset, errorcode, opmode;
@@ -163,7 +147,7 @@ int intel_early_me_init_done(u8 status)
 		if ((me_fws2 & 0x80) == 0x80) {
 			printk(BIOS_NOTICE, "CPU was replaced & warm reset required...\n");
 			pci_and_config16(PCI_DEV(0, 31, 0), 0xa2, ~0x80);
-			set_global_reset(0);
+			set_global_reset(false);
 			system_reset();
 		}
 
@@ -232,17 +216,17 @@ int intel_early_me_init_done(u8 status)
 		return 0;
 	case ME_HFS_ACK_RESET:
 		/* Non-power cycle reset */
-		set_global_reset(0);
+		set_global_reset(false);
 		reset |= 0x06;
 		break;
 	case ME_HFS_ACK_PWR_CYCLE:
 		/* Power cycle reset */
-		set_global_reset(0);
+		set_global_reset(false);
 		reset |= 0x0e;
 		break;
 	case ME_HFS_ACK_GBL_RESET:
 		/* Global reset */
-		set_global_reset(1);
+		set_global_reset(true);
 		reset |= 0x0e;
 		break;
 	case ME_HFS_ACK_S3:
diff --git a/src/southbridge/intel/bd82x6x/early_me_mrc.c b/src/southbridge/intel/bd82x6x/early_me_mrc.c
index 0b11fd0e81..847c708f42 100644
--- a/src/southbridge/intel/bd82x6x/early_me_mrc.c
+++ b/src/southbridge/intel/bd82x6x/early_me_mrc.c
@@ -96,22 +96,6 @@ int intel_early_me_uma_size(void)
 	return 0;
 }
 
-static inline void set_global_reset(int enable)
-{
-	u32 etr3 = pci_read_config32(PCH_LPC_DEV, ETR3);
-
-	/* Clear CF9 Without Resume Well Reset Enable */
-	etr3 &= ~ETR3_CWORWRE;
-
-	/* CF9GR indicates a Global Reset */
-	if (enable)
-		etr3 |= ETR3_CF9GR;
-	else
-		etr3 &= ~ETR3_CF9GR;
-
-	pci_write_config32(PCH_LPC_DEV, ETR3, etr3);
-}
-
 int intel_early_me_init_done(u8 status)
 {
 	u8 reset;
@@ -160,17 +144,17 @@ int intel_early_me_init_done(u8 status)
 		return 0;
 	case ME_HFS_ACK_RESET:
 		/* Non-power cycle reset */
-		set_global_reset(0);
+		set_global_reset(false);
 		reset = 0x06;
 		break;
 	case ME_HFS_ACK_PWR_CYCLE:
 		/* Power cycle reset */
-		set_global_reset(0);
+		set_global_reset(false);
 		reset = 0x0e;
 		break;
 	case ME_HFS_ACK_GBL_RESET:
 		/* Global reset */
-		set_global_reset(1);
+		set_global_reset(true);
 		reset = 0x0e;
 		break;
 	case ME_HFS_ACK_S3:
diff --git a/src/southbridge/intel/bd82x6x/me.c b/src/southbridge/intel/bd82x6x/me.c
index 3876b02306..462bc92e33 100644
--- a/src/southbridge/intel/bd82x6x/me.c
+++ b/src/southbridge/intel/bd82x6x/me.c
@@ -9,6 +9,7 @@
  */
 
 #include <acpi/acpi.h>
+#include <cf9_reset.h>
 #include <device/mmio.h>
 #include <device/device.h>
 #include <device/pci.h>
@@ -19,6 +20,9 @@
 #include <string.h>
 #include <delay.h>
 #include <elog.h>
+#include <halt.h>
+#include <option.h>
+#include <timer.h>
 
 #include "me.h"
 #include "pch.h"
@@ -183,6 +187,78 @@ void intel_me_finalize_smm(void)
 
 #else
 
+static bool enter_soft_temp_disable(void)
+{
+	/* The binary sequence for the disable command was found by PT in some vendor BIOS */
+	struct me_disable message = {
+		.rule_id = MKHI_DISABLE_RULE_ID,
+		.data = 0x01,
+	};
+	struct mkhi_header mkhi = {
+		.group_id	= MKHI_GROUP_ID_FWCAPS,
+		.command	= MKHI_FWCAPS_SET_RULE,
+	};
+	struct mei_header mei = {
+		.is_complete	= 1,
+		.length		= sizeof(mkhi) + sizeof(message),
+		.host_address	= MEI_HOST_ADDRESS,
+		.client_address	= MEI_ADDRESS_MKHI,
+	};
+	u32 resp;
+
+	if (mei_sendrecv(&mei, &mkhi, &message, &resp, sizeof(resp)) < 0
+			|| resp != MKHI_DISABLE_RULE_ID) {
+		printk(BIOS_WARNING, "ME: disable command failed\n");
+		return false;
+	}
+
+	return true;
+}
+
+static void enter_soft_temp_disable_wait(void)
+{
+	/*
+	 * TODO: Find smarter way to determine when we're ready to reboot.
+	 *
+	 * There has to be some bit in some register, or something, that indicates that ME has
+	 * finished doing its thing and we're ready to reboot.
+	 *
+	 * It was not found yet, though, and waiting for a response after the disable command is
+	 * not enough. If we reboot too early, ME will not be disabled on next boot. For now,
+	 * let's just wait for 1 second here.
+	 */
+	mdelay(1000);
+}
+
+static void exit_soft_temp_disable(struct device *dev)
+{
+	/* To bring ME out of Soft Temporary Disable Mode, host writes 0x20000000 to H_GS */
+	pci_write_config32(dev, PCI_ME_H_GS, 0x20000000);
+}
+
+static void exit_soft_temp_disable_wait(struct device *dev)
+{
+	struct me_hfs hfs;
+	struct stopwatch sw;
+
+	stopwatch_init_msecs_expire(&sw, ME_ENABLE_TIMEOUT);
+
+	/* Wait for fw_init_complete. Check every 50 ms, give up after 20 sec. */
+	do {
+		mdelay(50);
+		pci_read_dword_ptr(dev, &hfs, PCI_ME_HFS);
+		if (hfs.fw_init_complete)
+			break;
+	} while (!stopwatch_expired(&sw));
+
+	if (!hfs.fw_init_complete)
+		printk(BIOS_ERR, "ME: giving up on waiting for fw_init_complete\n");
+	else
+		printk(BIOS_NOTICE, "ME: took %lums to complete initialization\n",
+			stopwatch_duration_msecs(&sw));
+}
+
+
 /* Determine the path that we should take based on ME status */
 static me_bios_path intel_me_path(struct device *dev)
 {
@@ -252,10 +328,18 @@ static me_bios_path intel_me_path(struct device *dev)
 static void intel_me_init(struct device *dev)
 {
 	me_bios_path path = intel_me_path(dev);
+	u8 me_state = 0, me_state_prev = 0;
+	bool need_reset = false;
+	struct me_hfs hfs;
 
 	/* Do initial setup and determine the BIOS path */
 	printk(BIOS_NOTICE, "ME: BIOS path: %s\n", me_get_bios_path_string(path));
 
+	get_option(&me_state, "me_state");
+	get_option(&me_state_prev, "me_state_prev");
+
+	printk(BIOS_DEBUG, "ME: me_state=%u, me_state_prev=%u\n", me_state, me_state_prev);
+
 	switch (path) {
 	case ME_S3WAKE_BIOS_PATH:
 		intel_me_hide(dev);
@@ -270,6 +354,20 @@ static void intel_me_init(struct device *dev)
 		if (intel_mei_setup(dev) < 0)
 			break;
 
+		/* Put ME in Software Temporary Disable Mode, if needed */
+		if (me_state == CMOS_ME_STATE_DISABLED
+				&& CMOS_ME_STATE(me_state_prev) == CMOS_ME_STATE_NORMAL) {
+			printk(BIOS_INFO, "ME: disabling ME\n");
+			if (enter_soft_temp_disable()) {
+				enter_soft_temp_disable_wait();
+				need_reset = true;
+			} else {
+				printk(BIOS_ERR, "ME: failed to enter Soft Temporary Disable mode\n");
+			}
+
+			break;
+		}
+
 		if (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= BIOS_DEBUG) {
 			/* Print ME firmware version */
 			mkhi_get_fw_version();
@@ -283,12 +381,46 @@ static void intel_me_init(struct device *dev)
 		 */
 		break;
 
+	case ME_DISABLE_BIOS_PATH:
+		/* Bring ME out of Soft Temporary Disable mode, if needed */
+		pci_read_dword_ptr(dev, &hfs, PCI_ME_HFS);
+		if (hfs.operation_mode == ME_HFS_MODE_DIS
+				&& me_state == CMOS_ME_STATE_NORMAL
+				&& (CMOS_ME_STATE(me_state_prev) == CMOS_ME_STATE_DISABLED
+					|| !CMOS_ME_CHANGED(me_state_prev))) {
+			printk(BIOS_INFO, "ME: re-enabling ME\n");
+
+			exit_soft_temp_disable(dev);
+			exit_soft_temp_disable_wait(dev);
+
+			/*
+			 * ME starts loading firmware immediately after writing to H_GS,
+			 * but Lenovo BIOS performs a reboot after bringing ME back to
+			 * Normal mode. Assume that global reset is needed.
+			 */
+			need_reset = true;
+		} else {
+			intel_me_hide(dev);
+		}
+		break;
+
 	case ME_ERROR_BIOS_PATH:
 	case ME_RECOVERY_BIOS_PATH:
-	case ME_DISABLE_BIOS_PATH:
 	case ME_FIRMWARE_UPDATE_BIOS_PATH:
 		break;
 	}
+
+	/* To avoid boot loops if ME fails to get back from disabled mode,
+	 * set the 'changed' bit here. */
+	if (me_state != CMOS_ME_STATE(me_state_prev) || need_reset) {
+		u8 new_state = me_state | CMOS_ME_STATE_CHANGED;
+		set_option("me_state_prev", &new_state);
+	}
+
+	if (need_reset) {
+		set_global_reset(true);
+		full_reset();
+	}
 }
 
 static struct device_operations device_ops = {
diff --git a/src/southbridge/intel/bd82x6x/me.h b/src/southbridge/intel/bd82x6x/me.h
index 014fc1d9ea..21fc2add34 100644
--- a/src/southbridge/intel/bd82x6x/me.h
+++ b/src/southbridge/intel/bd82x6x/me.h
@@ -171,6 +171,22 @@ struct mei_header {
 #define MKHI_GLOBAL_RESET	0x0b
 
 #define MKHI_FWCAPS_GET_RULE	0x02
+#define MKHI_FWCAPS_SET_RULE	0x03
+
+#define MKHI_DISABLE_RULE_ID	0x06
+
+#define CMOS_ME_STATE(state)	(state & 0x1)
+#define CMOS_ME_CHANGED(state)	((state & 0x2) >> 1)
+#define CMOS_ME_STATE_NORMAL	0
+#define CMOS_ME_STATE_DISABLED	1
+#define CMOS_ME_STATE_CHANGED	2
+
+#define ME_ENABLE_TIMEOUT	20000
+
+struct me_disable {
+	u32 rule_id;
+	u32 data;
+} __packed;
 
 #define MKHI_MDES_ENABLE	0x09
 
@@ -247,6 +263,8 @@ int intel_mei_setup(struct device *dev);
 int intel_me_extend_valid(struct device *dev);
 void intel_me_hide(struct device *dev);
 
+void set_global_reset(bool enable);
+
 /* Defined in me_status.c for both romstage and ramstage */
 void intel_me_status(struct me_hfs *hfs, struct me_gmes *gmes);
 
diff --git a/src/southbridge/intel/bd82x6x/me_8.x.c b/src/southbridge/intel/bd82x6x/me_8.x.c
index d47c1da6b8..72e7d9ca85 100644
--- a/src/southbridge/intel/bd82x6x/me_8.x.c
+++ b/src/southbridge/intel/bd82x6x/me_8.x.c
@@ -9,6 +9,7 @@
  */
 
 #include <acpi/acpi.h>
+#include <cf9_reset.h>
 #include <device/mmio.h>
 #include <device/device.h>
 #include <device/pci.h>
@@ -19,6 +20,9 @@
 #include <string.h>
 #include <delay.h>
 #include <elog.h>
+#include <halt.h>
+#include <option.h>
+#include <timer.h>
 
 #include "me.h"
 #include "pch.h"
@@ -161,6 +165,78 @@ void intel_me8_finalize_smm(void)
 
 #else /* !__SIMPLE_DEVICE__ */
 
+static bool enter_soft_temp_disable(void)
+{
+	/* The binary sequence for the disable command was found by PT in some vendor BIOS */
+	struct me_disable message = {
+		.rule_id = MKHI_DISABLE_RULE_ID,
+		.data = 0x01,
+	};
+	struct mkhi_header mkhi = {
+		.group_id	= MKHI_GROUP_ID_FWCAPS,
+		.command	= MKHI_FWCAPS_SET_RULE,
+	};
+	struct mei_header mei = {
+		.is_complete	= 1,
+		.length		= sizeof(mkhi) + sizeof(message),
+		.host_address	= MEI_HOST_ADDRESS,
+		.client_address	= MEI_ADDRESS_MKHI,
+	};
+	u32 resp;
+
+	if (mei_sendrecv(&mei, &mkhi, &message, &resp, sizeof(resp)) < 0
+			|| resp != MKHI_DISABLE_RULE_ID) {
+		printk(BIOS_WARNING, "ME: disable command failed\n");
+		return false;
+	}
+
+	return true;
+}
+
+static void enter_soft_temp_disable_wait(void)
+{
+	/*
+	 * TODO: Find smarter way to determine when we're ready to reboot.
+	 *
+	 * There has to be some bit in some register, or something, that indicates that ME has
+	 * finished doing its thing and we're ready to reboot.
+	 *
+	 * It was not found yet, though, and waiting for a response after the disable command is
+	 * not enough. If we reboot too early, ME will not be disabled on next boot. For now,
+	 * let's just wait for 1 second here.
+	 */
+	mdelay(1000);
+}
+
+static void exit_soft_temp_disable(struct device *dev)
+{
+	/* To bring ME out of Soft Temporary Disable Mode, host writes 0x20000000 to H_GS */
+	pci_write_config32(dev, PCI_ME_H_GS, 0x20000000);
+}
+
+static void exit_soft_temp_disable_wait(struct device *dev)
+{
+	struct me_hfs hfs;
+	struct stopwatch sw;
+
+	stopwatch_init_msecs_expire(&sw, ME_ENABLE_TIMEOUT);
+
+	/* Wait for fw_init_complete. Check every 50 ms, give up after 20 sec. */
+	do {
+		mdelay(50);
+		pci_read_dword_ptr(dev, &hfs, PCI_ME_HFS);
+		if (hfs.fw_init_complete)
+			break;
+	} while (!stopwatch_expired(&sw));
+
+	if (!hfs.fw_init_complete)
+		printk(BIOS_ERR, "ME: giving up on waiting for fw_init_complete\n");
+	else
+		printk(BIOS_NOTICE, "ME: took %lums to complete initialization\n",
+			stopwatch_duration_msecs(&sw));
+}
+
+
 /* Determine the path that we should take based on ME status */
 static me_bios_path intel_me_path(struct device *dev)
 {
@@ -210,8 +286,7 @@ static me_bios_path intel_me_path(struct device *dev)
 
 	/* Check if the MBP is ready */
 	if (!gmes.mbp_rdy) {
-		printk(BIOS_CRIT, "%s: mbp is not ready!\n",
-		       __func__);
+		printk(BIOS_CRIT, "%s: mbp is not ready!\n", __func__);
 		path = ME_ERROR_BIOS_PATH;
 	}
 
@@ -240,10 +315,18 @@ static void intel_me_init(struct device *dev)
 {
 	me_bios_path path = intel_me_path(dev);
 	me_bios_payload mbp_data;
+	u8 me_state = 0, me_state_prev = 0;
+	bool need_reset = false;
+	struct me_hfs hfs;
 
 	/* Do initial setup and determine the BIOS path */
 	printk(BIOS_NOTICE, "ME: BIOS path: %s\n", me_get_bios_path_string(path));
 
+	get_option(&me_state, "me_state");
+	get_option(&me_state_prev, "me_state_prev");
+
+	printk(BIOS_DEBUG, "ME: me_state=%u, me_state_prev=%u\n", me_state, me_state_prev);
+
 	switch (path) {
 	case ME_S3WAKE_BIOS_PATH:
 		intel_me_hide(dev);
@@ -261,6 +344,20 @@ static void intel_me_init(struct device *dev)
 		if (intel_me_read_mbp(&mbp_data))
 			break;
 
+		/* Put ME in Software Temporary Disable Mode, if needed */
+		if (me_state == CMOS_ME_STATE_DISABLED
+				&& CMOS_ME_STATE(me_state_prev) == CMOS_ME_STATE_NORMAL) {
+			printk(BIOS_INFO, "ME: disabling ME\n");
+			if (enter_soft_temp_disable()) {
+				enter_soft_temp_disable_wait();
+				need_reset = true;
+			} else {
+				printk(BIOS_ERR, "ME: failed to enter Soft Temporary Disable mode\n");
+			}
+
+			break;
+		}
+
 		if (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= BIOS_DEBUG) {
 			me_print_fw_version(&mbp_data.fw_version_name);
 			me_print_fwcaps(&mbp_data.fw_caps_sku);
@@ -272,12 +369,46 @@ static void intel_me_init(struct device *dev)
 		 */
 		break;
 
+	case ME_DISABLE_BIOS_PATH:
+		/* Bring ME out of Soft Temporary Disable mode, if needed */
+		pci_read_dword_ptr(dev, &hfs, PCI_ME_HFS);
+		if (hfs.operation_mode == ME_HFS_MODE_DIS
+				&& me_state == CMOS_ME_STATE_NORMAL
+				&& (CMOS_ME_STATE(me_state_prev) == CMOS_ME_STATE_DISABLED
+					|| !CMOS_ME_CHANGED(me_state_prev))) {
+			printk(BIOS_INFO, "ME: re-enabling ME\n");
+
+			exit_soft_temp_disable(dev);
+			exit_soft_temp_disable_wait(dev);
+
+			/*
+			 * ME starts loading firmware immediately after writing to H_GS,
+			 * but Lenovo BIOS performs a reboot after bringing ME back to
+			 * Normal mode. Assume that global reset is needed.
+			 */
+			need_reset = true;
+		} else {
+			intel_me_hide(dev);
+		}
+		break;
+
 	case ME_ERROR_BIOS_PATH:
 	case ME_RECOVERY_BIOS_PATH:
-	case ME_DISABLE_BIOS_PATH:
 	case ME_FIRMWARE_UPDATE_BIOS_PATH:
 		break;
 	}
+
+	/* To avoid boot loops if ME fails to get back from disabled mode,
+	 * set the 'changed' bit here. */
+	if (me_state != CMOS_ME_STATE(me_state_prev) || need_reset) {
+		u8 new_state = me_state | CMOS_ME_STATE_CHANGED;
+		set_option("me_state_prev", &new_state);
+	}
+
+	if (need_reset) {
+		set_global_reset(true);
+		full_reset();
+	}
 }
 
 static struct device_operations device_ops = {
diff --git a/src/southbridge/intel/bd82x6x/me_common.c b/src/southbridge/intel/bd82x6x/me_common.c
index ae157d36c3..fb154aca00 100644
--- a/src/southbridge/intel/bd82x6x/me_common.c
+++ b/src/southbridge/intel/bd82x6x/me_common.c
@@ -421,3 +421,28 @@ void intel_me_hide(struct device *dev)
 }
 
 #endif
+
+void set_global_reset(bool enable)
+{
+#ifdef __SIMPLE_DEVICE__
+	u32 etr3 = pci_read_config32(PCH_LPC_DEV, ETR3);
+#else
+	struct device *lpc = pcidev_on_root(0x1f, 0);
+	u32 etr3 = pci_read_config32(lpc, ETR3);
+#endif
+
+	/* Clear CF9 Without Resume Well Reset Enable */
+	etr3 &= ~ETR3_CWORWRE;
+
+	/* CF9GR indicates a Global Reset */
+	if (enable)
+		etr3 |= ETR3_CF9GR;
+	else
+		etr3 &= ~ETR3_CF9GR;
+
+#ifdef __SIMPLE_DEVICE__
+	pci_write_config32(PCH_LPC_DEV, ETR3, etr3);
+#else
+	pci_write_config32(lpc, ETR3, etr3);
+#endif
+}
diff --git a/src/southbridge/intel/ibexpeak/Makefile.inc b/src/southbridge/intel/ibexpeak/Makefile.inc
index 277f686ba9..5c4893ed98 100644
--- a/src/southbridge/intel/ibexpeak/Makefile.inc
+++ b/src/southbridge/intel/ibexpeak/Makefile.inc
@@ -31,6 +31,7 @@ smm-y += smihandler.c me.c ../bd82x6x/me_8.x.c ../bd82x6x/me_common.c
 romstage-y += early_pch.c
 romstage-y +=../bd82x6x/early_me.c
 romstage-y +=../bd82x6x/me_status.c
+romstage-y +=../bd82x6x/me_common.c
 romstage-y += early_thermal.c
 romstage-y += ../bd82x6x/early_rcba.c
 romstage-y += early_cir.c
-- 
2.29.2

